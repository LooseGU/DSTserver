local _apLJ = require "widgets/widget" local _eW8L = require "widgets/image" local _lr0J = require "widgets/text" local _M8z4 = function(_FhPs, _xrJZ, _veaB, _X02A) return {r = _FhPs or 0x1, g = _xrJZ or 0x1, b = _veaB or 0x1, a = _X02A or 0x1, Get = function(_kg4f) return _kg4f.r, _kg4f.g, _kg4f.b, _kg4f.a end, Set = function(_LORx, _Nvac, _v6aP, _V2r4, _kqJT) _LORx.r = _Nvac or 0x1; _LORx.g = _v6aP or 0x1; _LORx.b = _V2r4 or 0x1; _LORx.a = _kqJT or 0x1; end, } end local _QWna = function(_VHYu) return math.min(math.max(_VHYu, 0x0), 0x1) end local _zzyF = function(_dtt0, _zrOb, _rGDz) return _dtt0 + (_zrOb - _dtt0) * _rGDz end local _euP4 = function(_J8q4, _HlzY) for _BRLf, _GPN6 in pairs(_J8q4) do if _GPN6 == _HlzY then return true end end return false end local _HELC = function(_IBE2, _LHCj) if not _euP4(_IBE2, _LHCj) then table.insert(_IBE2, _LHCj) end end local _sX5B = function(_23VB, _jE72) for _3FzS, _QIFL in pairs(_23VB) do if _QIFL == _jE72 then return _3FzS end end end local _3H1J = function(_Snvi, _Dys9) local _TqFN = _sX5B(_Snvi, _Dys9) if _TqFN then table.remove(_Snvi, _TqFN) end end local _VjnN = Class(_apLJ, function(_3mXd, _HTId) _apLJ._ctor(_3mXd, "DYC_SlicedImage" ) _3mXd.images = {} _3mXd.mode = "slice13" _3mXd.texScale = _HTId.texScale or 0x1 _3mXd.width = 0x64 _3mXd.height = 0x64 _3mXd:SetTextures(_HTId) end) function _VjnN:__tostring() return string.format( "%s (%s)" , self.name, self.mode) end function _VjnN:SetTextures(_cVld) assert(_cVld.mode) self.images = {} self.mode = _cVld.mode if self.mode == "slice13" or self.mode == "slice31" then local _c0pV = nil _c0pV = self:AddChild(_eW8L(_cVld.atlas, _cVld.texname.."_1.tex" )) _c0pV.oriW, _c0pV.oriH = _c0pV:GetSize() _c0pV.imgPos = 0x1 self.images[0x1] = _c0pV _c0pV = self:AddChild(_eW8L(_cVld.atlas, _cVld.texname.."_2.tex" )) _c0pV.oriW, _c0pV.oriH = _c0pV:GetSize() _c0pV.imgPos = 0x2 self.images[0x2] = _c0pV _c0pV = self:AddChild(_eW8L(_cVld.atlas, _cVld.texname.."_3.tex" )) _c0pV.oriW, _c0pV.oriH = _c0pV:GetSize() _c0pV.imgPos = 0x3 self.images[0x3] = _c0pV if self.mode == "slice13" then assert(self.images[0x1].oriH == self.images[0x3].oriH, "Height must be equal!" ) assert(self.images[0x1].oriH == self.images[0x2].oriH, "Height must be equal!" ) else assert(self.images[0x1].oriW == self.images[0x3].oriW, "Width must be equal!" ) assert(self.images[0x1].oriW == self.images[0x2].oriW, "Width must be equal!" ) end return elseif self.mode == "slice33" then local _6wSP = nil for _HN7V = 0x1, 0x3 do for _l7iN = 0x1, 0x3 do _6wSP = self:AddChild(_eW8L(_cVld.atlas, _cVld.texname.."_".._HN7V.._l7iN..".tex" )) _6wSP.oriW, _6wSP.oriH = _6wSP:GetSize() _6wSP.imgPos = _HN7V * 0xa + _l7iN self.images[_HN7V * 0xa + _l7iN] = _6wSP if _HN7V > 0x1 then assert(self.images[_HN7V * 0xa + _l7iN].oriW == self.images[(_HN7V - 0x1) * 0xa + _l7iN].oriW, "Width must be equal!" ) end if _l7iN > 0x1 then assert(self.images[_HN7V * 0xa + _l7iN].oriH == self.images[_HN7V * 0xa + _l7iN - 0x1].oriH, "Height must be equal!" ) end end end return end error( "Mode not supported!" ) self:SetSize() end function _VjnN:SetSize(_9V7H, _v1SR) _9V7H = _9V7H or self.width _v1SR = _v1SR or self.height if self.mode == "slice13" then local _UYc9 = self.images[0x1] local _OrfS = self.images[0x2] local _mp73 = self.images[0x3] local _aURz = math.min(self.texScale, math.min(_9V7H / (_UYc9.oriW + _mp73.oriW), _v1SR / _UYc9.oriH)) local _AIfp = _UYc9.oriW * _aURz local _ob1J = _mp73.oriW * _aURz local _K5eq = math.max(0x0, _9V7H - _AIfp - _ob1J) _UYc9:SetSize(_AIfp, _v1SR) _OrfS:SetSize(_K5eq, _v1SR) _mp73:SetSize(_ob1J, _v1SR) local _YORk = (_AIfp - _ob1J) / 0x2 local _hIai = - _AIfp / 0x2 - _K5eq / 0x2 + _YORk local _tTap = _ob1J / 0x2 + _K5eq / 0x2 + _YORk _UYc9:SetPosition(_hIai, 0x0, 0x0) _OrfS:SetPosition(_YORk, 0x0, 0x0) _mp73:SetPosition(_tTap, 0x0, 0x0) self.width = _AIfp + _K5eq + _ob1J self.height = _v1SR elseif self.mode == "slice31" then local _HpI6 = self.images[0x1] local _apMo = self.images[0x2] local _dHgX = self.images[0x3] local _WCCS = math.min(self.texScale, math.min(_v1SR / (_HpI6.oriH + _dHgX.oriH), _9V7H / _HpI6.oriW)) local _6DyT = _HpI6.oriH * _WCCS local _nZ3I = _dHgX.oriH * _WCCS local _HXVC = math.max(0x0, _v1SR - _6DyT - _nZ3I) _HpI6:SetSize(_9V7H, _6DyT) _apMo:SetSize(_9V7H, _HXVC) _dHgX:SetSize(_9V7H, _nZ3I) local _UJfR = (_6DyT - _nZ3I) / 0x2 local _HZR9 = - _6DyT / 0x2 - _HXVC / 0x2 + _UJfR local _D4Iv = _nZ3I / 0x2 + _HXVC / 0x2 + _UJfR _HpI6:SetPosition(0x0, _HZR9, 0x0) _apMo:SetPosition(0x0, _UJfR, 0x0) _dHgX:SetPosition(0x0, _D4Iv, 0x0) self.height = _6DyT + _HXVC + _nZ3I self.width = _9V7H elseif self.mode == "slice33" then local _tZmq = self.images local _I4xP = math.min(self.texScale, math.min(_9V7H / (_tZmq[0xb].oriW + _tZmq[0xd].oriW), _v1SR / (_tZmq[0xb].oriH + _tZmq[0x1f].oriH))) local _frl0, hs, xs, ys = {}, {}, {}, {} _frl0[0x1] = _tZmq[0xb].oriW * _I4xP _frl0[0x3] = _tZmq[0xd].oriW * _I4xP _frl0[0x2] = math.max(0x0, _9V7H - _frl0[0x1] - _frl0[0x3]) hs[0x1] = _tZmq[0xb].oriH * _I4xP hs[0x3] = _tZmq[0x1f].oriH * _I4xP hs[0x2] = math.max(0x0, _v1SR - hs[0x1] - hs[0x3]) xs[0x2] = (_frl0[0x1] - _frl0[0x3]) / 0x2 xs[0x1] = - _frl0[0x1] / 0x2 - _frl0[0x2] / 0x2 + xs[0x2] xs[0x3] = _frl0[0x3] / 0x2 + _frl0[0x2] / 0x2 + xs[0x2] ys[0x2] = (hs[0x1] - hs[0x3]) / 0x2 ys[0x1] = - hs[0x1] / 0x2 - hs[0x2] / 0x2 + ys[0x2] ys[0x3] = hs[0x3] / 0x2 + hs[0x2] / 0x2 + ys[0x2] for _vrcS = 0x1, 0x3 do for _vazn = 0x1, 0x3 do _tZmq[_vrcS * 0xa + _vazn]:SetSize(_frl0[_vazn], hs[_vrcS]) _tZmq[_vrcS * 0xa + _vazn]:SetPosition(xs[_vazn], ys[_vrcS], 0x0) end end self.width = _frl0[0x1] + _frl0[0x2] + _frl0[0x3] self.height = hs[0x1] + hs[0x2] + hs[0x3] end end function _VjnN:GetSize() return self.width, self.height end function _VjnN:SetTint(_EjEE, _Czq7, _UDpb, _4dzy) for _MNaM, _zgwC in pairs(self.images) do _zgwC:SetTint(_EjEE, _Czq7, _UDpb, _4dzy) end end function _VjnN:SetClickable(_xpwp) for _W9NC, _Fv1j in pairs(self.images) do _Fv1j:SetClickable(_xpwp) end end local _uSYi = Class(_apLJ, function(_OA4M, _ck5s) _apLJ._ctor(_OA4M, "DYC_TextHealthbar" ) _OA4M.text = _OA4M:AddChild(_lr0J(NUMBERFONT, 0x14, "" )) _OA4M.c1 = _ck5s.c1 or "=" _OA4M.c2 = _ck5s.c2 or "#" _OA4M.cnum = _ck5s.cnum or 0xa _OA4M.numCoeff = _ck5s.numCoeff or 0x1 _OA4M.percentage = 0x1 _OA4M.fontSize = _ck5s.fontSize or 0x14 _OA4M.hbScale = _ck5s.hbScale or 0x1 _OA4M:SetPercentage() _OA4M:SetHBScale() if _ck5s.color then _OA4M:SetTextColor(_ck5s.color) end end) function _uSYi:SetStrings(_1OgS, _aWXy, _Xchm) _1OgS = _1OgS or self.c1; _aWXy = _aWXy or self.c2; _Xchm = _Xchm or self.cnum; _Xchm = math.max(0x1, _Xchm) self.c1 = _1OgS; self.c2 = _aWXy; self.cnum = _Xchm; self:SetPercentage() end function _uSYi:SetLength(_cakV) _cakV = _cakV or self.cnum self.cnum = _cakV self:SetPercentage() end function _uSYi:SetPercentage(_0WGJ) _0WGJ = _0WGJ or self.percentage _0WGJ = math.max(0x0, math.min(_0WGJ, 0x1)) self.percentage = _0WGJ local _mqd4 = self.c1 local _Y189 = self.c2 local _lTzn = self.cnum * self.numCoeff local _texi = "" for _34CT = 0x1, _lTzn do if _0WGJ == 0x0 or (_34CT ~= 0x1 and _34CT * 1.0 / _lTzn > _0WGJ) then _texi = _texi.._mqd4 else _texi = _texi.._Y189 end end self.text:SetString(_texi) end function _uSYi:SetFontSize(_HCvs) _HCvs = _HCvs or self.fontSize self.fontSize = _HCvs self.text:SetSize(self.fontSize * self.hbScale) end function _uSYi:SetHBScale(_KLgN) _KLgN = _KLgN or self.hbScale self.hbScale = _KLgN self:SetFontSize() end function _uSYi:SetColor(_pjWq, _OvfL, _Kl4j, _XYmd) _pjWq = _pjWq or 0x1 _OvfL = _OvfL or 0x1 _Kl4j = _Kl4j or 0x1 _XYmd = _XYmd or 0x1 if type(_pjWq) == "table" then _pjWq.r = _pjWq.r or _pjWq.x or _pjWq[0x1] or 0x1 _pjWq.g = _pjWq.g or _pjWq.y or _pjWq[0x2] or 0x1 _pjWq.b = _pjWq.b or _pjWq.z or _pjWq[0x3] or 0x1 _pjWq.a = _pjWq.a or _pjWq[0x1] or 0x1 self.text:SetColour(_pjWq.r, _pjWq.g, _pjWq.b, _pjWq.a) else self.text:SetColour(_pjWq, _OvfL, _Kl4j, _XYmd) end end local _N328 = Class(_apLJ, function(_Nb25, _tWcT) _apLJ._ctor(_Nb25, "DYC_GraphicHealthbar" ) _Nb25:SetScaleMode(_tWcT.isDemo and SCALEMODE_NONE or SCALEMODE_PROPORTIONAL) _Nb25:SetMaxPropUpscale(0x3e7) _Nb25.worldOffset = Vector3(0x0, 0x0, 0x0) _Nb25.screen_offset = Vector3(0x0, 0x0, 0x0) _Nb25.isDemo = _tWcT.isDemo _Nb25.bg = _Nb25:AddChild(_eW8L(_tWcT.basic.atlas, _tWcT.basic.texture)) _Nb25.bg:SetClickable(_Nb25.isDemo or false) _Nb25.bg2 = _Nb25:AddChild(_eW8L(_tWcT.basic.atlas, _tWcT.basic.texture)) _Nb25.bg2:SetClickable(_Nb25.isDemo or false) _Nb25.text = _Nb25:AddChild(_lr0J(NUMBERFONT, 0x14, "" )) _Nb25.healthReductions = {} _Nb25.style = "textonbar" _Nb25.showBg = true _Nb25.showBg2 = true _Nb25.showValue = true _Nb25.hp = 0x64 _Nb25.hpMax = 0x64 _Nb25.percentage = 0x1 _Nb25.opacity = 0x1 _Nb25.hbScale = 0x1 _Nb25.hbYOffset = 0x0 _Nb25.hbWidth = 0x78 _Nb25.hbHeight = 0x12 _Nb25.barMargin = {x1 = 0x3, x2 = 0x3, y1 = 0x3, y2 = 0x3, fixed = true} _Nb25.fontSize = 0x14 _Nb25.hrDuration = 0.8 _Nb25.screenWidth = 0x780 _Nb25.screenHeight = 0x438 _Nb25.bgColor = _M8z4(0x1, 0x1, 0x1) _Nb25.bg2Color = _M8z4(0x0, 0x0, 0x0) _Nb25.barColor = _M8z4(0x1, 0x1, 0x1) _Nb25.hrColor = _M8z4(0x1, 0x1, 0x1) _Nb25.preUpdateFn = nil _Nb25.onSetPercentage = nil _Nb25:SetData(_tWcT) _Nb25:SetOpacity() _Nb25:SetHBSize(0x78, 0x12) _Nb25:SetFontSize(0x14) _Nb25:StartUpdating() _Nb25:AddToTable() end) _N328.ghbs = {} function _N328:AddToTable() _HELC(_N328.ghbs, self) end function _N328:SetData(_5Vtm) self.data = _5Vtm self.basicAtlas = _5Vtm.basic.atlas self.basicTex = _5Vtm.basic.texture self.bgAtlas = _5Vtm.bg and _5Vtm.bg.atlas self.bgTex = _5Vtm.bg and _5Vtm.bg.texture self.barAtlas = _5Vtm.bar and _5Vtm.bar.atlas self.barTex = _5Vtm.bar and _5Vtm.bar.texture self:SetBgSkn(_5Vtm.bgSkn) self:SetBarSkn(_5Vtm.barSkn) end function _N328:SetBgTexture(_VuTc, _7iJ7) self.bg:SetTexture(_VuTc, _7iJ7) self.bg2:SetTexture(_VuTc, _7iJ7) end function _N328:SetBgSkn(_8WHR) self.bgSknData = _8WHR or nil if self.bgSkn then self.bgSkn:Kill() self.bgSkn = nil end if self.bgSknData then self.bgSkn = self:AddChild(_VjnN(self.bgSknData)) self.bgSkn:SetClickable(self.isDemo or false) self.bgSkn:MoveToBack() self.showBg = false else self:SetBgTexture(self.bgAtlas or self.basicAtlas, self.bgTex or self.basicTex) self.showBg = true end if self.data and (self.data.bg2 or not self.data.bg) then self.showBg2 = true else self.showBg2 = false end self.bgColor = self.data and self.data.bg and self.data.bg.color or _M8z4(0x1, 0x1, 0x1) self.bg2Color = self.data and self.data.bg2 and self.data.bg2.color or _M8z4(0x0, 0x0, 0x0) end function _N328:SetBarSkn(_as5S) self.barSknData = _as5S or nil if self.bar then self.bar:Kill() self.bar = nil end if self.barSknData then self.bar = self:AddChild(_VjnN(self.barSknData)) self.bar:SetClickable(self.isDemo or false) self.bar:MoveToFront() self.text:MoveToFront() else self.bar = self:AddChild(_eW8L(self.barAtlas or self.basicAtlas, self.barTex or self.basicTex)) self.bar:SetClickable(self.isDemo or false) self.bar:MoveToFront() self.text:MoveToFront() end end function _N328:SetBarTexture(_qrPR, _Shan) if self.bar.SetTexture then self.bar:SetTexture(_qrPR, _Shan) end end function _N328:SetValue(_q161, _twPZ, _2RyD) self.hp = _q161 or self.hp self.hpMax = _twPZ or self.hpMax self.text:SetString(string.format( "%d/%d" , _q161, _twPZ)) self:SetPercentage(_q161 / _twPZ, _2RyD) end function _N328:SetYOffSet(_ekgE, _u4a0) _ekgE = _ekgE or self.hbYOffset self.hbYOffset = _ekgE local _Dl5a = self.screenWidth / 0x780 self:SetScreenOffset( - 0x5 * _Dl5a, self.hbYOffset * (_u4a0 and self.hbScale or 0x1) * _Dl5a) end function _N328:SetPercentage(_1tCN, _gMDN) local _uGVg = self.percentage _1tCN = _1tCN or self.percentage _1tCN = math.max(0x0, math.min(_1tCN, 0x1)) if _uGVg - _1tCN > 0.01 and not _gMDN and self.shown then self:DisplayHealthReduction(_uGVg, _1tCN) end self.percentage = _1tCN local _mSOL, h = self:GetSize() _mSOL = _mSOL or 0x1 h = h or 0x1 local _gSYs, barH = self:GetBarFullSize() local _4CNg, barVH = self:GetBarVirtualSize() local _kkwY = _gSYs - _4CNg * (0x1 - _1tCN) local _gjTf, oy = self:GetBarOffset() self.bar:SetSize(_kkwY, barH) self.bar:SetPosition( - (_gSYs - _kkwY) / 0x2 + _gjTf, oy, 0x0) if self.textHealthBar then self.textHealthBar:SetPercentage(_1tCN) end if self.onSetPercentage then self.onSetPercentage(self, _1tCN) end end function _N328:SetHBSize(_5599, _4cTq) _5599 = _5599 or self.hbWidth _4cTq = _4cTq or self.hbHeight _5599 = math.max(_5599, 0x0) _4cTq = math.max(_4cTq, 0x0) self.hbWidth = _5599 self.hbHeight = _4cTq _5599 = _5599 * self.hbScale _4cTq = _4cTq * self.hbScale self.bg:SetSize(_5599, _4cTq) self.bg2:SetSize(math.max(_5599 - 0x2, 0x0), math.max(_4cTq - 0x2, 0x0)) if self.bgSknData and self.bgSkn then local _nUiI, bgh = self:GetBgSknSize() self.bgSkn:SetSize(_nUiI, bgh) local _yarM, oy = self:GetBgOffset() self.bgSkn:SetPosition(_yarM, oy, 0x0) end self:SetPercentage() self:SetYOffSet() if self.textHealthBar then self.textHealthBar:SetFontSize(self.hbHeight * 0x1) end end function _N328:SetFontSize(_qzUV) _qzUV = _qzUV or self.fontSize self.fontSize = _qzUV self.text:SetSize(self.fontSize * self.hbScale) local _wMgz, h = self:GetSize() _wMgz = _wMgz or 0x1 h = h or 0x1 if self.style == "textoverbar" then self.text:SetPosition(0x0, h / 0x2 + self.fontSize * self.hbScale * 0.35, 0x0) elseif self.style == "barovertext" then self.text:SetPosition(0x0, - h / 0x2 - self.fontSize * self.hbScale * 0.35, 0x0) else self.text:SetPosition(0x0, 0x0, 0x0) end end function _N328:SetHBScale(_PwC5) _PwC5 = _PwC5 or self.hbScale self.hbScale = _PwC5 self:SetHBSize() self:SetFontSize() if self.textHealthBar then self.textHealthBar:SetHBScale(_PwC5) end end function _N328:SetStyle(_pPHk) _pPHk = _pPHk or self.style if _pPHk == self.style then return end self.style = _pPHk self:SetFontSize() end function _N328:SetOpacity(_WQkq) _WQkq = _WQkq or self.opacity self.opacity = _WQkq local _SORe = self.bgColor self.bg:SetTint(_SORe.r, _SORe.g, _SORe.b, self.showBg and _WQkq or 0x0) _SORe = self.bg2Color self.bg2:SetTint(_SORe.r, _SORe.g, _SORe.b, self.showBg and self.showBg2 and _WQkq or 0x0) _SORe = self.barColor self.bar:SetTint(_SORe.r, _SORe.g, _SORe.b, _WQkq) if self.bgSkn then self.bgSkn:SetTint(0x1, 0x1, 0x1, _WQkq) end end function _N328:SetBarColor(_8Hfk, _tfRj, _3THQ) _8Hfk = _8Hfk or 0x1 _tfRj = _tfRj or 0x1 _3THQ = _3THQ or 0x1 if type(_8Hfk) == "table" then self.barColor.r = _8Hfk.r or _8Hfk.x or _8Hfk[0x1] or 0x1 self.barColor.g = _8Hfk.g or _8Hfk.y or _8Hfk[0x2] or 0x1 self.barColor.b = _8Hfk.b or _8Hfk.z or _8Hfk[0x3] or 0x1 else self.barColor.r = _8Hfk self.barColor.g = _tfRj self.barColor.b = _3THQ end self:SetOpacity() if self.textHealthBar then self.textHealthBar:SetColor(_8Hfk, _tfRj, _3THQ) end end function _N328:SetTextColor(_z7St, _ZJtH, _JYaH, _m8VS) _z7St = _z7St or 0x1 _ZJtH = _ZJtH or 0x1 _JYaH = _JYaH or 0x1 _m8VS = _m8VS or 0x1 if type(_z7St) == "table" then _z7St.r = _z7St.r or _z7St.x or _z7St[0x1] or 0x1 _z7St.g = _z7St.g or _z7St.y or _z7St[0x2] or 0x1 _z7St.b = _z7St.b or _z7St.z or _z7St[0x3] or 0x1 _z7St.a = _z7St.a or _z7St[0x1] or 0x1 self.text:SetColour(_z7St.r, _z7St.g, _z7St.b, _z7St.a) else self.text:SetColour(_z7St, _ZJtH, _JYaH, _m8VS) end end function _N328:DisplayHealthReduction(_0a3L, _SQXY) local _G6gK = self.bg2:AddChild(_eW8L(self.basicAtlas, self.basicTex)) _G6gK:SetClickable(self.isDemo or false) local _OscF, h = self:GetSize() _OscF = _OscF or 0x1 h = h or 0x1 local _h0UZ, h2 = self:GetBarVirtualSize() local _71Bi = _h0UZ * math.max(0x0, _0a3L - _SQXY) local _ujEk = ((_SQXY + _0a3L) / 0x2 - 0.5) * _h0UZ local _HI7u, oy = self:GetBarVirtualOffset() local _u9t2 = self.data and self.data.hrUseBarColor and self.barColor or self.hrColor _G6gK:SetSize(_71Bi, h2) _G6gK:SetPosition(_ujEk + _HI7u, oy, 0x0) _G6gK:SetTint(_u9t2.r, _u9t2.g, _u9t2.b, self.opacity) _G6gK.fadeTimer = self.hrDuration table.insert(self.healthReductions, _G6gK) end function _N328:AnimateIn(_068T) self.animHBWidth = self.hbWidth self.animIn = true self.animSpeed = _068T or 0x5 self:SetHBSize(0x0, self.hbHeight) end function _N328:AnimateOut(_k3W2) self.animHBWidth = 0x0 self.animOut = true self.animSpeed = _k3W2 or 0x5 end function _N328:Kill() _3H1J(_N328.ghbs, self) _apLJ.Kill(self) end function _N328:OnMouseButton(_DT2q, _VEzv, _n6V9, _IUqJ, ...) local _lMr8 = _N328._base.OnMouseButton(self, _DT2q, _VEzv, _n6V9, _IUqJ, ...) if not _VEzv and _DT2q == MOUSEBUTTON_LEFT then self.dragging = false end if not self.focus then return false end if self.isDemo and _VEzv and _DT2q == MOUSEBUTTON_LEFT then self.dragging = true end return _lMr8 end function _N328:GetSize() return self.bg:GetSize() end function _N328:GetBgMargin() local _9VqP, h = self:GetSize() _9VqP = _9VqP or 0x1 h = h or 0x1 local _9kPl = self.bgSknData and self.bgSknData.margin or (self.data and self.data.bg and self.data.bg.margin) or {x1 = 0x0, x2 = 0x0, y1 = 0x0, y2 = 0x0, } local _2bOd = _9kPl.fixed and _9kPl.x1 or _9kPl.x1 * h local _eIPL = _9kPl.fixed and _9kPl.x2 or _9kPl.x2 * h local _qnyc = _9kPl.fixed and _9kPl.y1 or _9kPl.y1 * h local _iLgx = _9kPl.fixed and _9kPl.y2 or _9kPl.y2 * h return _2bOd, _eIPL, _qnyc, _iLgx end function _N328:GetBarMargin() local _outf, h = self:GetSize() _outf = _outf or 0x1 h = h or 0x1 local _PyHI = self.barSknData and self.barSknData.margin or (self.data and self.data.bar and self.data.bar.margin) or self.barMargin local _MY3R = _PyHI.fixed and _PyHI.x1 or _PyHI.x1 * h local _DnrL = _PyHI.fixed and _PyHI.x2 or _PyHI.x2 * h local _ZnDl = _PyHI.fixed and _PyHI.y1 or _PyHI.y1 * h local _sR49 = _PyHI.fixed and _PyHI.y2 or _PyHI.y2 * h return _MY3R, _DnrL, _ZnDl, _sR49 end function _N328:GetBarVirtualMargin() local _fPs7, h = self:GetSize() _fPs7 = _fPs7 or 0x1 h = h or 0x1 local _opZx = self.barSknData and self.barSknData.vmargin or (self.data and self.data.bar and self.data.bar.vmargin) or (self.barSknData and self.barSknData.margin) or (self.data and self.data.bar and self.data.bar.margin) or self.barMargin local _P2BP = _opZx.fixed and _opZx.x1 or _opZx.x1 * h local _0KGE = _opZx.fixed and _opZx.x2 or _opZx.x2 * h local _EgBq = _opZx.fixed and _opZx.y1 or _opZx.y1 * h local _P7ic = _opZx.fixed and _opZx.y2 or _opZx.y2 * h return _P2BP, _0KGE, _EgBq, _P7ic end function _N328:GetBgOffset() local _6Wn5, mx2, my1, my2 = self:GetBgMargin() return(_6Wn5 - mx2) / 0x2, (my1 - my2) / 0x2 end function _N328:GetBarOffset() local _i4fG, mx2, my1, my2 = self:GetBarMargin() return(_i4fG - mx2) / 0x2, (my1 - my2) / 0x2 end function _N328:GetBarVirtualOffset() local _ztaa, px2, py1, py2 = self:GetBarVirtualMargin() return(_ztaa - px2) / 0x2, (py1 - py2) / 0x2 end function _N328:GetBgSknSize() local _fJtw, h = self:GetSize() _fJtw = _fJtw or 0x1 h = h or 0x1 local _8FcK, mx2, my1, my2 = self:GetBgMargin() return math.max(_fJtw - _8FcK - mx2, 0x2), math.max(h - my1 - my2, 0x2) end function _N328:GetBarFullSize() local _WMVo, h = self:GetSize() _WMVo = _WMVo or 0x1 h = h or 0x1 local _R8Rl, mx2, my1, my2 = self:GetBarMargin() return math.max(_WMVo - _R8Rl - mx2, 0x2), math.max(h - my1 - my2, 0x2) end function _N328:GetBarVirtualSize() local _qOuh, h = self:GetSize() _qOuh = _qOuh or 0x1 h = h or 0x1 local _HpbB, px2, py1, py2 = self:GetBarVirtualMargin() return math.max(_qOuh - _HpbB - px2, 0x0), math.max(h - py1 - py2, 0x0) end function _N328:SetTarget(_b4pU) self.target = _b4pU self:OnUpdate() end function _N328:SetWorldOffset(_X5pH) self.worldOffset = _X5pH self:OnUpdate() end function _N328:SetScreenOffset(_KFy5, _Werj) self.screen_offset.x = _KFy5 self.screen_offset.y = _Werj self:OnUpdate() end function _N328:GetScreenOffset() return self.screen_offset.x, self.screen_offset.y end function _N328:OnUpdate(_4Hqu) _4Hqu = _4Hqu or 0x0 if self.target and self.target:IsValid() then if self.preUpdateFn then self.preUpdateFn(_4Hqu) end local _b8nj = nil if self.target.AnimState then _b8nj = Vector3(self.target.AnimState:GetSymbolPosition(self.symbol or "" , self.worldOffset.x, self.worldOffset.y, self.worldOffset.z)) else _b8nj = self.target:GetPosition() end if _b8nj then local _n3pV = Vector3(TheSim:GetScreenPos(_b8nj:Get())) _n3pV.x = _n3pV.x + self.screen_offset.x _n3pV.y = _n3pV.y + self.screen_offset.y self:SetPosition(_n3pV) end end if self.animOut and _4Hqu > 0x0 then if math.abs(self.hbWidth - self.animHBWidth) < 0x3 then self.animOut = false self:SetHBSize(self.animHBWidth, self.hbHeight) self:Kill() return else self:SetHBSize(_zzyF(self.hbWidth, self.animHBWidth, self.animSpeed * _4Hqu), self.hbHeight) end elseif self.animIn and _4Hqu > 0x0 then if math.abs(self.hbWidth - self.animHBWidth) < 0x1 then self.animIn = false self:SetHBSize(self.animHBWidth, self.hbHeight) else self:SetHBSize(_zzyF(self.hbWidth, self.animHBWidth, self.animSpeed * _4Hqu), self.hbHeight) end end local _82DZ = self.healthReductions if #_82DZ > 0x0 and _4Hqu > 0x0 then for _H2ue = #_82DZ, 0x1, - 0x1 do local _psX1 = _82DZ[_H2ue] _psX1.fadeTimer = _psX1.fadeTimer - _4Hqu if _psX1.fadeTimer < 0x0 then table.remove(_82DZ, _H2ue) _psX1:Kill() break end local _wnOm = self.data and self.data.hrUseBarColor and self.barColor or self.hrColor _psX1:SetTint(_wnOm.r, _wnOm.g, _wnOm.b, self.opacity * _psX1.fadeTimer / self.hrDuration) end end if self.showValue and not self.text.shown then self.text:Show() elseif not self.showValue and self.text.shown then self.text:Hide() end local _KVzl, sh = TheSim:GetScreenSize() if _KVzl ~= self.screenWidth or sh ~= self.screenHeight then self.screenWidth = _KVzl self.screenHeight = sh self:SetYOffSet() end if self.isDemo and self.dragging and _4Hqu > 0x0 then local _wkn9 = self:GetScale() local _9Qzd, y = TheInput:GetScreenPosition():Get() local _RgG3 = self:GetWorldPosition() local _PEIR, barH = self:GetBarVirtualSize() _PEIR = _PEIR * _wkn9.x barH = barH * _wkn9.y local _cIx3, oy = self:GetBarVirtualOffset() _cIx3 = _cIx3 * _wkn9.x oy = oy * _wkn9.y local _Tn3M = (_9Qzd - (_RgG3.x + _cIx3) + _PEIR / 0x2) / _PEIR self:SetPercentage(_Tn3M, true) if not self.focus then self.dragging = false end end end return _N328 